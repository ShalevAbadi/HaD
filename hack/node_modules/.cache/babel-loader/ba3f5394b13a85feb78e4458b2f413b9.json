{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observe = observe;\nexports.unobserve = unobserve;\nexports.destroy = destroy;\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    threshold: 0\n  };\n  var rootId = arguments[3];\n  var root = options.root,\n      rootMargin = options.rootMargin;\n  var threshold = options.threshold || 0;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : \"\" + threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var _observerId = instance.observerId,\n        _observer = instance.observer;\n    var observerInstance = _observerId ? OBSERVER_MAP.get(_observerId) : _observer;\n\n    if (observerInstance) {\n      // $FlowFixMe - the interface in bom.js is wrong. Spec should accept the element.\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (_observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === _observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(_observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n/**\n * Destroy all IntersectionObservers currently connected\n **/\n\n\nfunction destroy() {\n  OBSERVER_MAP.forEach(function (observer) {\n    observer.disconnect();\n  });\n  OBSERVER_MAP.clear();\n  INSTANCE_MAP.clear();\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling. Ignore this, and\n\n    if (instance && intersectionRatio >= 0) {\n      var _options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(_options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = _options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (_options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > _options.threshold : intersectionRatio >= _options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      if (instance.callback) {\n        instance.callback(_inView);\n      }\n    }\n  });\n}\n\nexports.default = {\n  observe: observe,\n  unobserve: unobserve,\n  destroy: destroy\n};","map":null,"metadata":{},"sourceType":"script"}